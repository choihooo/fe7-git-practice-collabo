---
name: Bug report
about: Create a report to help us improve
title: "[BUG]"
labels: ''
assignees: ''

---

### Git rebase interactive

= squash and merge with rebase 

<aside>
💡

지금 당장은 몰라도 되니 이런 방법도 있구나 정도만 알아두셔도 좋아요!

</aside>

지난 시간 진행한 git test repo 를 열어봅시다!

`본인이름한글로` 브랜치에서 `git log --oneline` 입력해보시면 

우리 지금까지 했던 수많은 커밋 내역들이 보일겁니다. 

이제 전에 했던 커밋 이력을 squash 해줄 겁니다.

이 방법의 정식 명칭은,

> Git rebase interactive : 기존 커밋을 수정, 삭제, 이동, 생성이 가능함.
> 

🧐 **사용방법**

1. `git rebase -i 수정할_커밋의_직전_커밋아이디` or `git rebase -i HEAD~숫자`
    1. `git rebaes -i 수정할_커밋의_직전_커밋아이디` : 여기에 적은 커밋아이디 그 다음부터 현재 커밋까지 모든 커밋을 가져옴 (추천방법)
    2. `git rebase -i HEAD~3` : 최신 커밋으로부터 HEAD 포함하여 3번째 커밋까지 가져옴
2. 입력하면 5가지 옵션 사용이 가능함
    
    ```jsx
    pick - 커밋 순서를 재정렬하거나 해당 커밋을 수정 없이 그대로 사용한다는 의미
    reword - 커밋 메시지 수정
    edit - 커밋 수정
    squash - 이전 커밋과 merge하여 단일 커밋으로 변경
    fixup - squash와 비슷하지만 기존 커밋 메시지를 무시
    drop - 커밋을 삭제
    ```
    
3. 5가지 옵션 중 원하는 동작 선택하고 continue를 통해 작업 완료
    
    `git rebase --continue`
    

🫥 **그럼 이건 언제, 왜 써요?**

- 작업할 땐 몰랐는데.. 과거 커밋 메시지에 오타가 있다?! 😱
- 테스트 용도로 작업한 커밋들이 왜 저기에… 딸려감..? 🫠
- 흠, 비슷한 커밋이 두 개로 분리되어 잇네.. 하나로 합칠 수는 없나? 🤔
- 아… 누가 보기 전에 커밋 수정하고 싶다..!!! 😵‍💫

이럴 때 사용할 수 있는 것이 바로 `git rebase` 인데요, 

일반적으로 우리가 배운 `rebase` 라고 함은

두 개의 브랜치를 합치는 용도로 `git merge` 와 함께 쓰이는 것으로 배웠죠.

**현재 작업중인 브랜치의 최신 커밋을 가리키는 HEAD 포인터를 이동시킬 수 있다는 특성**을 이용해서

과거 커밋 히스토리를 수정하는 데에도 사용할 수 있답니다.

그 중에서 대화형으로 실행할 수 있는 옵션인  `--interactive` (또는 `-i` ) 를 이용해서

커밋 히스토리를 수정해볼 수 있어요.

🧐 **`git rebase --interactive` 직접 사용해봅시다!**

- 실제 사용방법 예시 `watch` → `try-again`
    1. git log 로 `커밋 아이디`를 확인한다. (위에서부터 최신 커밋 순으로 보여줌)
        
        ![나는 여기서 testrebase 1 과 testrebase2
        이 친구들을 squash하여 하나의 commit으로 만들고 싶다.](attachment:43884e7a-d857-4b23-be5b-cfbff56183c4:스크린샷_2025-02-26_오후_9.19.03.png)
        
        나는 여기서 testrebase 1 과 testrebase2
        이 친구들을 squash하여 하나의 commit으로 만들고 싶다.
        
    2. 수정하려는 커밋의 `이전 커밋 아이디`를 입력해야 한다.
        
        즉, testrebase1 보다 이전 커밋인 rebase test main 친구, 6440fa0 을 사용해야 한다.
        
        → `git rebase -i 6440fa0`
        
    3. 그럼 아래와 같이 vim 이 켜진다. (여기서는 맨 밑이 최신 커밋이다. 즉, 위에서부터 오래된 커밋순)
        
        ![스크린샷 2025-02-26 오후 9.23.15.png](attachment:e205066a-dc88-4372-beab-fd5ebc8f1aab:스크린샷_2025-02-26_오후_9.23.15.png)
        
    4. i 를 입력하면 수정 할 수 있게 바뀐다.
    5. 아래 사진과 같이 testrebase 2 커밋 아이디 앞에 s 로 바꿔준다.
        
        ![나는 testrebase 1과 testrebase 2를 합쳐야 하므로 
        testrebase 2 커밋을 squash 해야 이전 커밋인 testrebase 1과 합쳐지게 된다.
        즉, 합치고 싶은 2개의 커밋 중 가장 최신 커밋에 s 를 입력하여 squash 해준다!](attachment:df535985-08a1-4cf7-803e-73bd32ce7174:스크린샷_2025-02-26_오후_9.26.33.png)
        
        나는 testrebase 1과 testrebase 2를 합쳐야 하므로 
        testrebase 2 커밋을 squash 해야 이전 커밋인 testrebase 1과 합쳐지게 된다.
        즉, 합치고 싶은 2개의 커밋 중 가장 최신 커밋에 s 를 입력하여 squash 해준다!
        
    6. esc > :wq 를 입력하여 vim을 탈출한다.
    7. 그럼 2개의 commit을 어떤 commit message로 합칠 것인지 작성하는 vim이 또 나온다.
        
        ![스크린샷 2025-02-26 오후 9.26.55.png](attachment:6e409dfe-3009-4941-82fc-03e7db545490:스크린샷_2025-02-26_오후_9.26.55.png)
        
    8. 여기서 똑같이 `i > commit message 작성 > esc > :wq` 해준다.
        
        ![혹시 i를 입력해도  INSERT 모드로 바뀌지 않는다면 한/영 키보드를 눌러봐라. 한글 모드여서 그럴 수 있다.](attachment:57548a81-a990-417b-8c69-1b40bc1129bf:스크린샷_2025-02-26_오후_9.31.00.png)
        
        혹시 i를 입력해도  INSERT 모드로 바뀌지 않는다면 한/영 키보드를 눌러봐라. 한글 모드여서 그럴 수 있다.
        
    9. 여기까지 왔다면 이렇게 잘 스쿼시 됬다는 메시지를 볼 수 있다.
        
        ![스크린샷 2025-02-26 오후 9.32.08.png](attachment:d01715af-ff13-4d86-8c5a-1e7fbb00c6f8:스크린샷_2025-02-26_오후_9.32.08.png)
        
    10. 마지막으로 `git log --oneline` 으로 확인해보자.
        
        ![testrebase 1,2 squash merge 로 예쁘게 squash된 커밋을 볼 수 있다 :) ](attachment:d20460aa-b613-4a30-b5f0-8e0162761a3d:스크린샷_2025-02-26_오후_9.33.02.png)
        
        testrebase 1,2 squash merge 로 예쁘게 squash된 커밋을 볼 수 있다 :) 
        

<aside>
💡

알아두면 언젠가 쓸모 있을지도 모르는 pick 사용해서 순서 변경하는 방법

(사실 쓸 일은 많이 없어서 해보진 않겠습니다. 궁금하신 분들은 아래 내용 살펴보세요!)

- pick을 이용해 commit 위치 변경하기
    
    ![이 둘의 순서를 바꿔보려고 한다.](attachment:4d0812e7-8a62-4f92-b57c-79c0df6cb335:스크린샷_2025-02-26_오후_9.35.12.png)
    
    이 둘의 순서를 바꿔보려고 한다.
    
    1. 현재 HEAD의 위치로부터 6번째 아래에 있으므로 `git rebase -i HEAD~6` 을 입력해준다.
        
        ![스크린샷 2025-02-26 오후 9.38.05.png](attachment:b290a6e0-c77f-454e-8fa4-23ff023a4533:스크린샷_2025-02-26_오후_9.38.05.png)
        
    2. 수동으로 906c94d 커밋아이디를 가진 부분을 4bc598e 아래로 이동시켜준다.
        
        ![이때 pick 을 그대로 사용하는 것이 포인트✨](attachment:8c572ae2-7c79-4d5d-913e-cb5a33424334:스크린샷_2025-02-26_오후_9.39.29.png)
        
        이때 pick 을 그대로 사용하는 것이 포인트✨
        
    3. 그럼 conflict 날 것임. 수정하고 `git add .` 해서 staged area에 추가해주세요.
        
        ![스크린샷 2025-02-26 오후 9.42.08.png](attachment:6fb3d38d-2a67-4a02-a5cf-bd9fce9c4320:스크린샷_2025-02-26_오후_9.42.08.png)
        
    4. 다음 commit으로 이동하기 위해 `git rebase --continue` 를 입력하면 또 vim 떠요.
        
        ![스크린샷 2025-02-26 오후 9.44.08.png](attachment:30177d82-5014-4f3d-b073-a87fdce225df:스크린샷_2025-02-26_오후_9.44.08.png)
        
        그냥 이대로 저장하기 위해 :wq 해줄게요.
        
    5. 저는 confict 또 났습니다. 그럼 또 충돌 해결하고 add → rebase continue 해줍니다.
        
        ![또 수정하고 add → rebase continue 했는데 충돌 또 나서](attachment:08968ffa-590d-4a5d-95e7-c006074b112e:스크린샷_2025-02-26_오후_9.46.02.png)
        
        또 수정하고 add → rebase continue 했는데 충돌 또 나서
        
        ![또 수정하고 add → continue 해줌.](attachment:6aa07504-97d0-4753-8ba7-171832151bef:스크린샷_2025-02-26_오후_9.46.29.png)
        
        또 수정하고 add → continue 해줌.
        
        ~~이 뒤로도 충돌 5번 더 나서 add → continue 무한 반복함. 진짜 이럴때마다 포기하고 싶음.~~
        
        <aside>
        💡
        
        여기서 만약 rebase interactive를 포기하고 원복하고 싶다면 `git rebase --abort` 입력
        
        </aside>
        
    6. 무한 반복하다보면 conflict이 사라지고 rebase가 종료될 것임
        
        ![Successfully rebase 어쩌구 ~~ 이 내용이 뜰때까지 무한 반복하세요.](attachment:44419a45-13d2-44a8-a571-2f0f5e2ae4fd:스크린샷_2025-02-26_오후_9.50.01.png)
        
        Successfully rebase 어쩌구 ~~ 이 내용이 뜰때까지 무한 반복하세요.
        
    7. 여기까지 왔다면 `git status`로 commit 해야할 거 있는지 확인하고 있으면 add →  commit 
        
        ![커밋까지하고 git status 확인해보면 nothing to commit 으로 뜰겁니다.](attachment:9dc48a02-7138-4922-bfc8-3fa92d51d960:스크린샷_2025-02-26_오후_9.52.54.png)
        
        커밋까지하고 git status 확인해보면 nothing to commit 으로 뜰겁니다.
        
    8. git log 확인해보면 잘 바뀐 것 확인할 수 있어요.
        
        ![순서  바꾸겠다고 충돌 내역 수정하고 커밋한 것에 대한 커밋이 전 생겼네요. 
        빨간색 박스 보시면 순서가 잘 바뀌었죠? 힘들었다🫨](attachment:edf7b1be-d713-4940-8e6c-3d1ec4374b98:스크린샷_2025-02-26_오후_9.54.41.png)
        
        순서  바꾸겠다고 충돌 내역 수정하고 커밋한 것에 대한 커밋이 전 생겼네요. 
        빨간색 박스 보시면 순서가 잘 바뀌었죠? 힘들었다🫨
        
    9. 끝입니다. ~~지금 6단계도 충돌 땜에 힘든데 너무 오래 전 커밋 순서 바꾸는 건 미친 짓이겠죠?~~

혹시 다른 옵션들도 사용법 궁금하다면 [아티클](https://wormwlrm.github.io/2020/09/03/Git-rebase-with-interactive-option.html) 읽어보시길..

</aside>

### Git에는 전략이 있어요.

개발자 10명이서 브랜치를 대충 아무렇게나 만들면 개발과정이 매우 복잡해지고 추적도 어려워서

git branch 깔끔하게 만들도록 도와주는 방법론 같은게 있습니다.

git flow, github flow, gitlab flow, trunk-based 등 다양한 것들이 있어요.

이런걸 적용하면

**1. 브랜치관리가 쉬워지고**

**2. 팀원이 아무리 많아도 개발 절차가 매끄러워집니다.**

그래서 프로젝트 리드하는 사람들은 무조건 알아야 하고, 

우리도 개발팀에 들어가면 팀의 git 전략이 정해져있을 겁니다.

> **git flow**
> 

우리가 만드는 프로그램이 항상 안정적인 release(배포)를 해야할 때 사용합니다. (예를 들면, 게임개발처럼)

![출처 : https://blog.jetbrains.com/space/2023/04/18/space-git-flow/](attachment:5ebc41aa-b492-4bee-a131-a96645cbc850:스크린샷_2025-02-26_오후_10.39.58.png)

출처 : https://blog.jetbrains.com/space/2023/04/18/space-git-flow/

😵‍💫 **좀 더 이해하기 쉽게 설명해볼게요**.

우리 이제 곧 서비스 ver 1.0 런칭해야 하는데, 아직 신기능 개발할 게 많은 상황입니다.

그래서 팀원들과 함께 git flow 를 도입해서 개발을 진행하려고 해요.

![스크린샷 2025-02-26 오후 11.11.36.png](attachment:6f111734-b657-436f-8a03-d5582d4e1ddd:스크린샷_2025-02-26_오후_11.11.36.png)

main에서 develop 브랜치부터 만들어줄게요.

그럼 develop 브랜치에서 다같이 개발하고 바로 main으로 합치면 될까요?

팀원 중 한명이 신입이라면, 곧 런칭해야 하는데 어떤 에러 날 지 몰라요.

그러니까 지금부터 모든 개발은 develop 브랜치에서 진행하라고 할거에요.

![스크린샷 2025-02-26 오후 11.11.43.png](attachment:bec88a77-adde-4068-b8ca-62fb681e7704:스크린샷_2025-02-26_오후_11.11.43.png)

이제 팀원들 각각 부여받은 기능이 있을 거에요.

모두가 develop 브랜치에서 만드는 것이 아닙니다.

각자 develop 복사한 feature브랜치 따서 개발할겁니다.

`feature/invitaion` 브랜치 만들어서 초대 기능 만들고,

`feature/friend` 브랜치 만들어서 친구 기능 만들겁니다.

(`feature/friend` 혹은 `feature-friend` 로 작명함)

이제 각 feature마다 개발 완료되면 develop에 merge할겁니다. ~~(어벤져스 모이는 느낌ㅋ)~~

![스크린샷 2025-02-26 오후 11.31.05.png](attachment:934b92af-8c74-49ef-b93e-4b517ae366f7:스크린샷_2025-02-26_오후_11.31.05.png)

`develop`에서 만든 신기능 2개가 각각 완성되어 올라온 상태에요.

이걸 바로 main 에 합치기엔 또 불안하죠. (늘 배포는 쫄보 마인드로.._)

그래서 `develop`에서 `release`라는 브랜치를 또 복사한 다음 테스트하고 고칠 게 있다면 고칩니다.

- `release` 브랜치에서 버그 발견하면 임시 브랜치 만들어서 수정하고 합쳐줍니다.
- 보통 `release/1.0` 처럼 예쁘게 브랜치명 짓습니다.

✔️ `release`의 변경 내역들도 전부 `develop` 브랜치에 반영해줘야 해요.

이제 진짜 수정할 거 없다. 싶으면 `main` 브랜치로 merge 합니다.

`main` 브랜치에 올라간 코드를 유저에게 배포하는 겁니다.

<aside>
👉🏻

또 이어서 개발은 계속 되어야 하니, 꼭 `release` 의 내용들을 `develop` 에도 merge 해주세요.

</aside>

![스크린샷 2025-02-26 오후 11.32.02.png](attachment:67b35248-febf-4216-8962-2eee397b4a5c:스크린샷_2025-02-26_오후_11.32.02.png)

유저한테 배포 다했는데, 갑자기 미친 버그를 발견하게 됬다면..!

`main` 브랜치에서 급하게 `hotfix` 라는 이름의 브랜치를 만들어서 바로 버그 수정하고 올려주면 됩니다.

→ 즉, 수정 완료하면 main 브랜치에 직접 merge 하면 됨.

<aside>
👉🏻

당연히 develop 브랜치에서 merge 해주셔야 개발자들이 해당 변경사항 포함해서 개발 가능합니다.

</aside>

전체 구조를 보면 이렇습니다.

![스크린샷 2025-02-26 오후 11.34.00.png](attachment:7a8c08df-6b5d-42e9-860f-0df78c632c51:스크린샷_2025-02-26_오후_11.34.00.png)

🧐 **git flow 의 장점은 뭐냐고요?**

브랜치별 역할이 정해져 있고, 배포하기 전 release에서 배타 테스트와 수정 후 배포하기 때문에

안정적으로 버전별 배포가 가능해집니다.

<aside>
✔️

그래서 이거 언제 쓰면 적합해요?

- 우리가 만드는 프로그램이 항상 안정적인 release(배포)를 해야할 때
- 버전 별로 차곡차곡 배포해야 할 때
</aside>

여기까지 git flow 에 대한 설명인데, 꼭 이 모든 브랜치들을 **전부 사용할 필요는 없습니다.**

git flow 전략을 가져가되, 우리는 release 브랜치 제외하고 develop 에서 테스트 + 수정하고 

바로 main으로 merge 해서 배포한다! 라고 하셔도 되요.

(작은 규모에서 빠르게, 자주 배포해야 하는 상황이라면 그럴 수 있겠죠)

우리의 변형에 이유만 있으면 됩니다.

개발자는 항상 `“왜”`가 중요합니다.

> **github flow**
> 

![출처 : https://blog.jetbrains.com/space/2023/04/18/space-git-flow/](attachment:2850a30d-ab1a-4594-97f3-115822dbb774:스크린샷_2025-02-26_오후_10.40.49.png)

출처 : https://blog.jetbrains.com/space/2023/04/18/space-git-flow/

trunk-based 랑 거의 비슷함. 다만 `PR` 로 merge 하는 것이 github flow 의 특징

> **trunk-based**
> 

![출처 : https://blog.jetbrains.com/space/2023/04/18/space-git-flow/](attachment:cb08f7c9-323a-439f-a6da-93e7c3ecff30:스크린샷_2025-02-26_오후_10.41.05.png)

출처 : https://blog.jetbrains.com/space/2023/04/18/space-git-flow/

trunk-based는 `브랜치 하나만 잘 관리하는 전략`이에요.

![스크린샷 2025-02-26 오후 11.58.54.png](attachment:bbd8b7a5-c4da-4032-ad0c-78384407d6e8:스크린샷_2025-02-26_오후_11.58.54.png)

1. 기능 추가, 버그 수정이 필요하면 main 브랜치에서 새로운 브랜치를 하나 만들어서 코드짭니다.
    
    → 이때 브랜치명을 잘 지어주는 것이 중요합니다.
    
2. 기능이 완성되면 main 브랜치에 합칩니다.
3. 합치고 나서 쓸모없어진 브랜치는 삭제합니다.
4. main 브랜치에 있는 코드를 필요할 때마다 유저들에게 배포합니다.

🧐 **trunk-based 의 장점은 뭐냐고요?**

- 코드를 한 브랜치에서만 관리하기 때문에 편리합니다.
- 크게 개발해서 한 번에 merge 하는 것 보다 작은 단위로 merge 하는 것이 더 안전합니다.

하지만 main 브랜치에 있는 코드가 뻑나면 큰일나기 때문에 테스트나 코드 리뷰를 자주해야 합니다.

그래서 테스트를 자주하고 자동화 해놓은 곳들에서 제대로 사용가능합니다.

<aside>
✔️

그래서 이거 언제 쓰면 적합해요?

- 우리가 만든 코드를 바로 유저에게 배포해도 상관 없을 때
- 크게 대격변의 업데이트를 안하는 안정적인 프로그램일 때
</aside>

<aside>
💡

정리

- 어느 정도 개발이 진행되었거나 코딩 천재들만 있는 팀이라면 → trunk-based 훨씬 편리
- 출시된 버전의 안전성이 중요한 프로그램들, 아직 뼈대가 확실하지 않아 연구식, 실험식으로 개발하는 프로그램들
    
    → git flow 가 적절할 수 있음
    

(이것도 정답은 아님, 각 전략을 선택하는 이유만 있으면 됨)

</aside>

### Github의 🌸 - 타인과 협업하는 다양한 방법 알아보기

> git clone
> 

원격 저장소에 프로젝트를 내 로컬 컴퓨터에 그대로 복제해 오는 것

💡 내 레포에 팀원이랑 협업하고 싶을 때

github repo에서 아래처럼 팀원 깃헙아이디 등록해놔야 팀원들이 git push가능해집니다.

![전 이거 맨날 까먹어요ㅎㅎ; 여러분은 까먹지 마시길..](attachment:a7e699a1-91bc-486d-a54a-0428d4b0c14e:스크린샷_2025-02-27_오전_8.47.33.png)

전 이거 맨날 까먹어요ㅎㅎ; 여러분은 까먹지 마시길..

우리 협업할 때 내 코드만 올라오는 거 아니고 동료의 코드도 올라와서

내 로컬에는 없는 코드가 원격 저장소에는 올라가 있을 거에요.

그때 바통 터치로 이어 받아서 내 코드도 올리는 작업이 협업 이죠.

그래서 가상으로 협업하는 연습을 해볼겁니다.

### 바로 실습) git clone 으로 복제하고, pull + push 할 거에요.

1. 협업 연습용 레포를 실습 폴더에 clone 해주세요.

https://github.com/groom-practice/fe7-git-practice-collabo

1. 각자 `본인이름한글로` 브랜치 만들어서 [README.md](http://README.md) 에 본인이름 적어주고 add → commit → push
    
    (당연히 main push 안됩니다.)
    
2. 여기서 Github 자체에서 `본인이름한글로` 브랜치에 리드미를 수정하여 새로운 커밋을 만들어볼게요. 
(이걸 타인이 올린 코드라고 생각할게요.)
3. 자, 이제 여기서 `본인이름한글로` 에서도 수정사항을 만들어서 add → commit 해주세요.
4. 한번 `본인이름한글로` 로 push 해보시면 에러가 날겁니다.
    
    ![스크린샷 2025-10-26 오후 3.46.34.png](attachment:6d45d25a-91bc-44e3-8e84-7052386060bd:스크린샷_2025-10-26_오후_3.46.34.png)
    
    <aside>
    💡
    
    에러가 나는 이유는 다른 사람 코드랑 내 코드랑 변경 사항이 겹칠 수 있는데
    
    대충 push 하게 해주면 코드가 덮어씌워지거나 꼬일 거에요.
    
    그래서 git 이 그걸 알아채고 미리 코드가 꼬이지 않도록 예방해주는 겁니다.
    
    </aside>
    
5. 이때 사용하는 명령어가 `git pull origin 본인이름한글로` 입니다.
    
    현재 원격저장소에서 `본인이름한글로` 브랜치에 있는 내용 중 변경사항을 전부 로컬로 가져오는 명령어 입니다.
    
    ![pull 시도했을 때 이런 오류가 뜰 수 있어요! 
    어떻게 pull 땡겨올건지 선택하라는거니까 저희는 그냥 merge 방식으로 선택해볼게요.](attachment:fdb4c069-d290-46e6-bbb7-ae6134b1c147:스크린샷_2025-10-26_오후_3.48.28.png)
    
    pull 시도했을 때 이런 오류가 뜰 수 있어요! 
    어떻게 pull 땡겨올건지 선택하라는거니까 저희는 그냥 merge 방식으로 선택해볼게요.
    
6. pull 이후 충돌이 날 수 있습니다. 해결하고 저장하고 커밋까지 동일하게 진행합니다.
7. 최신화 완료되었다면 `git push origin 본인이름한글로` 해봅니다. push가 잘 될 거에요.

<aside>
💡

git pull vs git fetch 많이들 헷갈려 하셔서 정리했어요.

- git pull = git fetch + git merge
    - git fetch : 원격 저장소에 있는 커밋 중에 로컬에 없는 신규 커밋을 가져와라.
    - git merge : 가져온 걸 병합해라.
- 그래서 다른 팀원과 같은 파일을 건드리면 git pull 했을 때 merge conflict 날 수 있어요.
그럴 땐 그냥 충돌 해결하시고 add → commit 해주시면 됩니다.
</aside>

📢 그래서 결론은 뭐다? **push 하기 전에 습관적으로 pull 땡기자.**

> fork
> 

: 다른 사람의 레포를 내 소유의 레포로 복사하는 것

![스크린샷 2025-02-27 오후 2.17.03.png](attachment:e2bb3684-3feb-4cf2-9449-a9e51d5c743c:스크린샷_2025-02-27_오후_2.17.03.png)

기본적인 구조는 이래요. 

옆에 붙은 upstream, origin을 원격 저장소 별칭입니다. 

암묵적으로 사용하는 약속 별칭이니까 지켜주시는 게 좋아요.

🧐 fork는 어떻게 해요?

![스크린샷 2025-02-27 오후 10.53.02.png](attachment:178eb514-6b2c-4360-9436-6e87ede571b8:스크린샷_2025-02-27_오후_10.53.02.png)

![스크린샷 2025-02-27 오후 10.53.23.png](attachment:d84027a2-58dd-4494-8d7d-008d252f4eea:스크린샷_2025-02-27_오후_10.53.23.png)

자, 그럼 복사한 원본 레포 groom-practice/git-practice-collabo 가 upstream 이 되는 것이고.

복제한 내 레포 lisarnjs/git-practice-collabo 가 origin 이 되겠습니다.

💡upstream downstream 은 상대적인 개념이에요.

- origin과 local을 기준으로 생각하면 `origin = upstream` / `local = downstream`
- fork repo를 기준으로 생각하면 `원본repo = upstream` / `origin = downstream`

✔️ 보통 깃헙으로 협업할 때 사용하는 프로세스는 대부분 이렇습니다.

1. '원본 remote repository'(upstream)를 깃허브에서 fork
2. 'fork한 remote repository'(origin)를 깃 클라이언트(내 로컬)로 clone
3. 기능을 완성할 때까지 아래 반복
    1. clone한 repository(즉, 내 로컬)에 개발 & commit
    2. local에서 origin(즉, 내 깃헙의 복사한 레포)으로 push
4. 기능이 완성되면 upstream에 반영하기
    1. PR을 등록하기 전 upstream에 **바뀐 내용이 없는 경우**
        1. origin에서 upstream으로 PR(Pull Request)
    2. PR을 등록하기 전 upstream에 **바뀐 내용이 있는 경우**
        1. upstream을 local로 pull 
            - 이때 필요한 명령어
                
                `git remote add upstream 원본레포URL` → `git pull upstream 가져올브랜치명`
                
        2. local에서 origin으로 push
            - 이때 필요한 명령어
                
                `git push origin 브랜치명`
                
        3. origin에서 upstream으로 PR(Pull Request)

<aside>
💡

TIP

`git remote -v` 로 내가 저장한 저장소의 별칭을 확인하여

pull 혹은 push 할 때 헷갈리지 않도록 주의해주세요!

</aside>

> Pull Request (PR)
> 

우리 지금까지 브랜치 만들고 다양한 머지 방법들 배워봤는데

어쨌든 우리가 신기능 개발할 때 다른 브랜치 파서 개발하는 게 안전합니다.

이렇게 각자 브랜치에서 개발한 걸 main에 합쳐야하는데

그때 보통 CLI (명령어) 를 사용하는 것보다 PR 을 더 많이 사용해서 merge 합니다.

이유는 팀끼리 일하는 경우 merge하기 전에 코드 리뷰를 하거나, 검토하거나, 토론해야 하는 경우가 있기 때문

### 먼저, github 에 PR 을 어떻게 올리면 되는지 같이 볼게요. `watch`

1. `git-practice-collabo` 레포에 `본인이름한글로` 브랜치 만들었었죠.
2. `본인이름한글로`의 변경 사항을 main 으로 보내기 위해 PR 을 생성합니다.
    
    → 이때 주의할 것은 `어떤 브랜치를 어디에 합칠 것인지 선택하는 것`을 잘 보셔야 합니다.
    
3. 충돌 있다면 해결하고, 머지해주면 끝.

<aside>
💡

실습은 아래에 있으니 일단 내용 계속 따라가주세요!

</aside>

✔️ **PR을 merge할 때 여러가지 옵션이 있어요.**

![스크린샷 2025-02-27 오후 2.46.18.png](attachment:c8a70293-13bd-4801-9eef-251367de0287:스크린샷_2025-02-27_오후_2.46.18.png)

1. create a merge commit
    
    : 새로운 merge commit 하나 생성해주는 3-way merge 실행해줍니다.
    
    → main 브랜치 조회 시 합쳐진 브랜치의 commit 내역들도 전부 나오겠죠?
    
    → 그래서 혹시 commit 내역이 많은 PR이라면 복잡해질 수 있습니다.
    
2. squash and merge
    
    : 합쳐질 브랜치의 commit 내역들을 하나로 합쳐서 main 브랜치에 신규 commit 을 생성해줍니다.
    
    → 우리 진공포장으로 압축한다고 했던 거 기억하죠?
    
    → 단, 커밋 내역들이 이미 의도대로, 기능대로 잘 나뉘었거나 
    또는 main 브랜치에 commit 기록이 남아야 한다면 3-way 를 선택해주셔야겠죠!
    
3. rebase and merge
    
    : 합쳐질 브랜치를 main 브랜치의 최신 커밋으로 재배치하고 나서 fast-forward merge처럼 해줍니다.
    
    → 결과는 squash and merge와 비슷하지만 합쳐질 브랜치의 커밋 내역이 전부 보존됩니다.
    

> 코드 리뷰
> 

한 개발자가 코드를 작성하면 다른 개발자가 정해진 방법으로 피드백을 주고 받는 과정

🤔 코드 리뷰 왜 할까요?

- 본인은 발견하지 못한 실수를 다른 사람이 발견하여 코드의 부작용(side effect)과 오류에 조기 대응가능
- 개발 내 정해진 컨벤션 규칙을 유지하고 기술의 부채를 줄일 수 있음
- 여러 개발자가 참여함으로써 문제 해결을 위한 기술 구현 방법론에 대해 공유하기도 함

실제로 현업에서 코드 리뷰를 진행할 때 팀원, 팀장 모두가 함께 참여할 수 있어요.

그래서 효과적인 코드 리뷰를 위해 리뷰어(리뷰하는 사람)의 자세가 굉장히 중요한데,

나중에 팀 사이드 프로젝트 할 때에도 올바른 코드 리뷰가 오고 가면 엄청난 성장을 할 수 있으니

리뷰의 5가지 규칙을 알아볼게요.

✔️ 리뷰의 5가지 규칙

1. 왜 개선이 필요한지 이유를 충분히 설명해야 합니다.
    - 예시
        
        ```jsx
        const data = [
          ['데이터베이스', 'A', 3],
          ['교양영어', 'B+', 1],
          ['철학', 'A', 2]
        ];
        ```
        
        위 코드는 2차원 배열을 사용한 자료 구조이며, 학점 정보를 담고 있는 data 라는 변수가 있습니다.
        
        여기서 문제는 변수명만 봐서는 어떤 의도를 가진 변수인지 파악하기 어렵고,
        
        데이터가 확장되거나 비슷한 자료 구조가 추가될 때 문제가 생길 수 있어요.
        
        리뷰어의 좋은 리뷰와 안 좋은 리뷰를 살펴볼게요.
        
        ```jsx
        // 좋은 리뷰
        “data라는 이름은 현재의 자료구조가 무엇인지 그 의도를 알기가 어렵네요.
        학점 정보를 담고 있는 자료구조 같은데 이와 관련된 변수명을 짓는다면
        현재 정의한 자료구조가 무엇인지 그 의도를 쉽게 파악할 수 있을 것 같아요.”
        
        // 안 좋은 리뷰
        “data 변수 말고 다른 변수명으로 하세요."
        “data 변수 말고 grade로 하세요.”
        ```
        
        좋은 리뷰는 왜 변수명을 바꿔야 할지, 어떻게 개선하면 좋을지를 제시하고 있는 반면,
        
        안 좋은 리뷰는 명령형으로 바로 해결책만 제시하고 있죠.
        
2. 답을 알려주기보다는 스스로 고민하고 개선 방법을 선택할 수 있게 해줘야 합니다.
    - 예시
        
        사실 코드 리뷰는 시간이 오래 걸려요. 그래서 명령형으로 작성하게 되는 경우가 많습니다.
        
        그렇게 답을 알려주는 리뷰를 많이 받을 수록 내 코드에 대한 애정도 사라지고
        
        수동적인 개발자가 되어 스스로 고민하고 개선하는 방법을 찾지 못하게 됩니다.
        
        ```jsx
        const result = [];
        arr.forEach(item => {
          if(item % 2 === 0) {
            result.push(item);
          }
        });
        ```
        
        위 코드는 배열 순회해서 짝수의 값만 result 배열에 추가하는 코드에요 (곧 배우니 지금은 몰라도 됨)
        
        ```jsx
        // 좋은 리뷰
        “자바스크립트에는 배열에는 다양한 내장 메서드들이 존재합니다.
        그중 filter 메서드를 활용해 보세요.
        이 메서드를 활용하면 코드량을 줄일 수 있습니다.”
        
        // 안 좋은 리뷰
        “arr.filter(item => item % 2 === 0);으로 사용하세요."
        ```
        
        같은 해결책을 알려주지만 다른 방식으로 알려주고 있죠.
        
        좋은 리뷰는 답을 알려주는 게 아닌 키워드(filter)를 알려줌으로써 어떤 식으로 검색해야 하는지
        
        방법을 제시하고 있는 피드백으로, 리뷰이(리뷰 받는 사람) 입장에서 스스로 찾아보고 학습하면서
        
        스스로 고민하여 고쳐볼 수 있는 기회가 생깁니다.
        
        반면, 안 좋은 리뷰를 읽게 되면 filter 동작 방식은 제대로 이해하지 못한 채 복붙해서 수정하게 되고,
        
        비슷한 코드가 여러 군데 있지만 이곳만 수정할 수도 있어요.
        
3. 코드를 클린 하게 유지하고, 일관되게 구현하도록 안내해줘야 합니다.
    - 예시
        
        클린 코드는 코드의 품질을 높이고, 가독성을 높이면서 일의 생산성을 향상시켜줍니다.
        
        (나중에 더 자세히 알아보도록 하죠)
        
        그래서 리뷰어는 조각 조각 보는 것보다 전체를 보고 일관된 코드인지 확인해주면 좋아요.
        
4. 리뷰 과정은 숙제 검사가 아닌  학습 과정으로 느낄 수 있도록 신경 써서 리뷰 해야 합니다.
    - 예시
        
        위에서 얘기한 답을 알려주는 피드백과 비슷한 내용이지만,
        
        리뷰이의 의도를 파악하지 않은채 답을 알려주거나, 틀렸다 라는 것을 바로 말하면 안됩니다.
        
        ```jsx
        // 좋은 리뷰
        "Component 클래스를 상속 받는 건 좋네요.
        그러나 자식 클래스에서 부모 클래스를 호출만 하기 때문에 모든 클래스에서
        상속받는 건 오히려 중복 코드 같아 보이기도 하는데 이렇게 작성해 주신 이유가 있을까요?"
        
        // 안 좋은 리뷰
        “클래스 상속은 필요 없습니다.”
        ```
        
        좋은 리뷰를 보면 ‘중복 코드’라는 단어를 사용하며 상속이 불필요한 이유를 설명하면서,
        
        리뷰이의 의도가 있을 수 있기 때문에 먼저 의도를 물어봐주죠.
        
        그럼 리뷰이는 본인이 왜 이렇게 코드를 작성했는지 다시 되돌아볼겁니다.
        
        그 과정에서 어떤 부분을 수정해야 되는지 고민하고 학습할 수 있는 계기가 될거에요.
        
5. 리뷰를 위한 리뷰를 하지 마세요. 피드백 할 것 없다면 칭찬해 주시면 됩니다.
    - 칭찬 피드백 예시
        - 코드량이 적당해서 읽기 편하네요.
        - 많은 고민이 코드에서 엿보이네요.
        - 성능에 아주 유리한 코드라고 생각되네요.
        - 전에 코드보다 훨씬 좋아진 거 같네요.
        - 예외 처리가 꽤 꼼꼼해서 좋네요.
        - 함수, 변수명이 직관적이어서 좋네요.

코드 리뷰라는 것은, 굉장한 커뮤니케이션 비용이 드는 일입니다.

그래서 어쨌든 서로 텍스트로 주고 받는 리뷰가 비난하는 듯한 느낌을 받지 않게끔 작성하는 것이 가장 중요해요.

<aside>
❓

자, 그럼 리뷰어만 잘하면 될까요?

NOPE! 당연히 리뷰이도 코드 리뷰하기 좋은 PR을 올리면 더 좋은 코드 리뷰를 받을 수 있겠죠?

</aside>

> 브랜치 규칙 설정하기
> 

여러 명이 함께 개발하는 경우, 브랜치 규칙을 추가해 주요 브랜치(`main`)로의 잘못된 병합을 방지할 수 있어요.

(단, 깃헙 무료 계정은 public repo 만 설정가능함)

- Github 에서 브랜치 규칙 설정하는 방법 `→ main 으로 push 바로 안 되도록 만들기`
    1. 브랜치 규칙 세팅할 레포 들어가서 `New branch ruleset` 클릭하세요.
        
        ![스크린샷 2025-02-28 오전 7.04.20.png](attachment:0f75201b-b392-418e-8371-879a0f8008f1:스크린샷_2025-02-28_오전_7.04.20.png)
        
    2. 용어들 설명보면서 하나씩 설정해주세요.
        
        Ruleset Name = 규칙의 이름
        
        Enforcement status = 규칙 상태
        
        Active = 활성화
        
        Bypass list = 규칙을 우회할 수 있는 역할(Role)
        
        → 저장소의 소유자가 급할 때 push할 수 있도록 지정하거나 우리가 배포할 때 사용하는 서비스 Vercel처럼 배포할 때 이상 없도록 bypass list 지정해줄 수 있어요.
        
        ![스크린샷 2025-02-28 오전 7.04.45.png](attachment:71b9f07e-dfa4-46d0-beaf-87af76ad8500:스크린샷_2025-02-28_오전_7.04.45.png)
        
    3. Targets 에서는 보호할 대상 브랜치 즉, push 를 막을 브랜치를 선택합니다.
        
        **Add target → Include by pattern → main,release 등 원하는 패턴으로 지정**
        
        ![스크린샷 2025-02-28 오전 7.05.03.png](attachment:569707f7-0a36-445e-b28f-5b3f5d11df45:스크린샷_2025-02-28_오전_7.05.03.png)
        
    4. 추가적으로 세부 규칙까지 적용할 수 있어요.
        - 규칙 설명 보기
            - Required approvals: PR 병합에 필요한 최소 리뷰어 수를 지정합니다. 지정된 리뷰어 수 이상이 승인해야 PR을 병합할 수 있습니다.
            - Dismiss stale pull request approvals when new commits are pushed: 출처 브랜치에 새로운 커밋이 푸시되면, 이전 PR 승인이 취소됩니다. 예를 들어, 어떤 리뷰어의 승인을 받았는데, 이후에(병합 전) 코드가 변경되면 다시 승인이 필요하다는 의미입니다.
            - Require review from Code Owners: 특정 파일의 코드 소유자가 있는 경우, 해당 파일을 수정한 PR은 코드 소유자의 승인을 필수로 받아야 합니다.
            - Require approval of the most recent reviewable push: 코드 작성자가 자신의 코드를 승인할 수 없고 다른 리뷰어가 승인해야 합니다.
            - Require conversation resolution before merging: 모든 리뷰가 해결(Resolve)돼야 PR 병합이 가능합니다.
        
        ![스크린샷 2025-02-28 오전 7.05.10.png](attachment:0da3d40a-21a9-4e1f-8783-c1de55af7286:스크린샷_2025-02-28_오전_7.05.10.png)
        
    5. 저장하면
        
        ![스크린샷 2025-02-28 오전 7.05.22.png](attachment:e6e0fe65-5aa3-49e0-b28f-811083e1dd86:스크린샷_2025-02-28_오전_7.05.22.png)
        
    6. 이렇게 규칙이 활성화됩니다.
        
        ![스크린샷 2025-02-28 오전 7.05.47.png](attachment:727e3e29-ee6c-4614-899e-90b734dd35a4:스크린샷_2025-02-28_오전_7.05.47.png)
        

### 좋은 코드 리뷰를 받기 위한 좋은 PR 만드는 방법

> 1️⃣ commit 막 하지 말자
> 

지금까지 우리 수정 사항 만들고 스테이징하고 커밋하면서 여러가지 실습을 진행했는데

우리 마음대로 대충 커밋 메시지 작성해왔다면 이제는 현업에서 어떻게 커밋하는지 알려드릴게요.

🧐 commit 이 코드 리뷰에 무슨 영향을 끼쳐요?

커밋 메시지는 리뷰어에게 이정표 같은 역할을 한답니다. 잘 정리된 커밋은 코드 리뷰에 큰 도움을 줘요.

✔️ commit 할 때 이제는 이 원칙들을 생각하자.

1. **커밋에도 순서가 있습니다.**
    
    의식의 흐름대로 커밋하면 코드를 짠 본인도 이 커밋이 도대체 뭐를 위한 커밋인지 모릅니다.
    
    그래서 본인만의 기준을 정해서 커밋하면, 어떤 작업이 어디에 있는지 금방 찾을 수 있어요.
    
    예를 들면 ‘파일 추가 → 화면 구현 → 기능 구현’ 순서를 지켜서 커밋을 만든다던지?!
    
    (모든 개발 끝나면 rebase or sqaush 통해서 커밋 정리하면 좋겠죠?)
    
2. **커밋은 작을수록 좋아요.**
    - 하나의 커밋은 하나의 작업 단위만 포함하는 것이 좋습니다.
        
        예를 들면, `'A페이지의 B라는 버그 픽스'`와 `'A페이지의 C한 부분을 리팩토링'` 은 
        
        이처럼 각각 2개의 커밋으로 나눠지는 것이 좋아요. 
        
        (너무 작은 커밋 같은데.. 싶어도 거대한 커밋보다는 훨씬 낫습니다.)
        
    - 여러 페이지에 같은 기능을 추가한다 하여도 커밋은 나누는 것이 좋습니다.
        
        예를 들면, `친구 초대 기능`을 메인페이지에도 추가하고, 유저 페이지에도 추가할 때
        
        둘을 한 번에 개발하여 커밋하지 말고 `유저 페이지의 친구 초대 기능 추가` 로
        
        바운더리를 나눠주는 것이 좋아요.
        
        (그냥 `친구 초대 기능 전체 추가` 라는 커밋을 보면 어디에, 어떤 파일을 수정했는지 알 수 X)
        
    

1. **커밋 메시지에 의미를 부여합시다.**
    - Commit Convention
        - 기본 커밋 컨벤션 구조
            
            ```jsx
            제목 (Type: Subject)
            (한줄 띄어 분리)
            본문 (Body)
            (한줄 띄어 분리)
            꼬리말 (Footer)
            ```
            
            우리 git commit 만 입력하면 vim 이 나왔던 것 기억하죠?
            
            vim 에 위 구조를 맞추어 내용을 작성해주면 됩니다.
            
            ```jsx
            // 예시
            Feat: 회원 가입 기능 구현
            
            SMS, 이메일 중복확인 API 개발
            
            Resolves: #123
            Ref: #456
            Related to: #48, #45
            ```
            
        - Commit Type
            
            
            | Tag Name | Description |
            | --- | --- |
            | Feat | 새로운 기능을 추가 |
            | Fix | 버그 수정 |
            | Design | CSS 등 사용자 UI 디자인 변경 |
            | !BREAKING CHANGE | 커다란 API 변경의 경우 |
            | !HOTFIX | 급하게 치명적인 버그를 고쳐야하는 경우 |
            | Style | 코드 포맷 변경, 세미 콜론 누락, 코드 수정이 없는 경우 |
            | Refactor | 프로덕션 코드 리팩토링 |
            | Comment | 필요한 주석 추가 및 변경 |
            | Docs | 문서 수정 |
            | Test | 테스트 코드, 리펙토링 테스트 코드 추가, Production Code(실제로 사용하는 코드) 변경 없음 |
            | Chore | 빌드 업무 수정, 패키지 매니저 수정, 패키지 관리자 구성 등 업데이트, Production Code 변경 없음 |
            | Rename | 파일 혹은 폴더명을 수정하거나 옮기는 작업만인 경우 |
            | Remove | 파일을 삭제하는 작업만 수행한 경우 |
        - Footer 내용
            
            : 선택사항임, 보통 이슈 트래커 적어줌
            
            ```jsx
            // 이슈 트래커 유형
            Fixes: 이슈 수정중 (아직 해결되지 않은 경우)
            Resolves: 이슈를 해결했을 때 사용
            Ref: 참고할 이슈가 있을 때 사용
            Related to: 해당 커밋에 관련된 이슈번호 (아직 해결되지 않은 경우)
            ```
            
        - 추가로 commit type 작성하실 때 [gitmoji](https://gitmoji.dev/) 사용해서 예쁘게 꾸미시는 분들도 있어요.
            - 저는 귀찮아서 안하지만 원하시는 분들을 위해
                
                
                | Emoji | Description |
                | --- | --- |
                | 🎨 | 코드의 형식 / 구조를 개선 할 때 |
                | 📰 | 새 파일을 만들 때 |
                | 📝 | 사소한 코드 또는 언어를 변경할 때 |
                | 🐎 | 성능을 향상시킬 때 |
                | 📚 | 문서를 쓸 때 |
                | 🐛 | 버그 reporting할 때, @FIXME 주석 태그 삽입 |
                | 🚑 | 버그를 고칠 때 |
                | 🐧 | 리눅스에서 무언가를 고칠 때 |
                | 🍎 | Mac OS에서 무언가를 고칠 때 |
                | 🏁 | Windows에서 무언가를 고칠 때 |
                | 🔥 | 코드 또는 파일 제거할 때 , @CHANGED주석 태그와 함께 |
                | 🚜 | 파일 구조를 변경할 때 . 🎨과 함께 사용 |
                | 🔨 | 코드를 리팩토링 할 때 |
                | ☔️ | 테스트를 추가 할 때 |
                | 🔬 | 코드 범위를 추가 할 때 |
                | 💚 | CI 빌드를 고칠 때 |
                | 🔒 | 보안을 다룰 때 |
                | ⬆️ | 종속성을 업그레이드 할 때 |
                | ⬇️ | 종속성을 다운 그레이드 할 때 |
                | ⏩ | 이전 버전 / 지점에서 기능을 전달할 때 |
                | ⏪ | 최신 버전 / 지점에서 기능을 백 포트 할 때 |
                | 👕 | linter / strict / deprecation 경고를 제거 할 때 |
                | 💄 | UI / style 개선시 |
                | ♿️ | 접근성을 향상시킬 때 |
                | 🚧 | WIP (진행중인 작업)에 커밋, @REVIEW주석 태그와 함께 사용 |
                | 💎 | New Release |
                | 🔖 | 버전 태그 |
                | 🎉 | Initial Commit |
                | 🔈 | 로깅을 추가 할 때 |
                | 🔇 | 로깅을 줄일 때 |
                | ✨ | 새로운 기능을 소개 할 때 |
                | ⚡️ | 도입 할 때 이전 버전과 호환되지 않는 특징, @CHANGED주석 태그 사용 |
                | 💡 | 새로운 아이디어, @IDEA주석 태그 |
                | 🚀 | 배포 / 개발 작업 과 관련된 모든 것 |
                | 🐘 | PostgreSQL 데이터베이스 별 (마이그레이션, 스크립트, 확장 등) |
                | 🐬 | MySQL 데이터베이스 특정 (마이그레이션, 스크립트, 확장 등) |
                | 🍃 | MongoDB 데이터베이스 특정 (마이그레이션, 스크립트, 확장 등) |
                | 🏦 | 일반 데이터베이스 별 (마이그레이션, 스크립트, 확장명 등) |
                | 🐳 | 도커 구성 |
                | 🤝 | 파일을 병합 할 때 |
        
        자, 이렇게 본문까지 작성하기 귀찮아서 `-m` 을 사용하게 된다면  
        
        더욱 `commit type: 커밋 메시지` 를 신경써서 구체적으로 적어주시길 바래요!
        

> 2️⃣ Github ISSUE + PR Template 활용하기
> 

먼저, 템플릿 만들기 전에 github에 있는 issue, project 에 대한 간략한 설명부터 하자면.

👉🏻 issue (이슈)

: 프로젝트의 `기획`, `작업`, `개선사항`, `버그수정`, `새로 추가될 기능` 등 모든 것을 `이슈` 라고 합니다.

깃헙에서는 이 모든 활동에 대한 이슈를 등록하고, 그것을 기반으로 작업을 진행할 수 있어요.

Jira 라는 일정 관리 툴을 현업에서 많이 사용하는데, 이 친구도 이슈를 생성해서 작업합니다.

👉🏻 projects

: 깃헙에 있는 projects 탭은 말 그대로 프로젝트를 만들 수 있다. 

- 프로젝트 만드는 순서는 이렇습니다. 보통 칸반 보드 형태를 많이 사용해요.
    
    ![스크린샷 2025-02-27 오후 5.32.23.png](attachment:fac48a40-64c6-4d57-bf76-9adae792a3de:스크린샷_2025-02-27_오후_5.32.23.png)
    
    ![스크린샷 2025-02-27 오후 5.32.44.png](attachment:df2401fe-7318-4511-8a2d-3fb04d622843:스크린샷_2025-02-27_오후_5.32.44.png)
    
    ![스크린샷 2025-02-27 오후 5.33.09.png](attachment:7767ac2a-d5a3-499e-a5a1-538c508bea69:스크린샷_2025-02-27_오후_5.33.09.png)
    
    ![스크린샷 2025-02-27 오후 5.33.44.png](attachment:b6ae3400-4e65-4bea-8af0-315b61ea2aeb:스크린샷_2025-02-27_오후_5.33.44.png)
    

![➕ 추가적으로, 프로젝트에서 TODO를 입력하게 되면 해당 내용을 바로 issue 등록 가능!](attachment:7231a9d2-2693-4872-aed6-a5372660a74b:f46a8593-51a8-4c5f-b7fe-dd7043addf7c.png)

➕ 추가적으로, 프로젝트에서 TODO를 입력하게 되면 해당 내용을 바로 issue 등록 가능!

이렇게 깃헙 자체 프로젝트로 코드 PR 보내면서 서로 작업 진행도 확인하고 관리합니다.

- ISSUE template 만드는 법
    1. github repo 들어가서 상단 탭에 `settings`에 들어간다.
    2. 아래 조금 내리면 `Features` 섹션에 해당 버튼이 보일 것이다.
        
        ![스크린샷 2025-02-27 오후 4.49.51.png](attachment:45e7f79e-f5bd-4f31-ab28-9cc172d34fe6:스크린샷_2025-02-27_오후_4.49.51.png)
        
    3. 들어가면 template 추가할 수 있는 버튼이 있다. 그 중에 어떤 유형의 이슈 템플릿인지 선택
        
        ![스크린샷 2025-02-27 오후 4.51.04.png](attachment:f6d26366-6821-4fa5-8e83-9829169e6821:스크린샷_2025-02-27_오후_4.51.04.png)
        
    4. 이슈 템플릿은 여러 개 만들 수 있다. 
        1. Bug report = 버그 리포트
        2. Feature request = 기능 요청
        3. Custom template = 각 팀별로 개발 외 다른 용도로 이슈를 사용할 수 있다
    5. 이슈 유형 선택했다면 해당 버튼을 눌러 양식을 수정할 수 있다.
        
        ![스크린샷 2025-02-27 오후 5.01.40.png](attachment:0ae9b346-1392-449f-8f05-fa51d3e1bed0:스크린샷_2025-02-27_오후_5.01.40.png)
        
    6. 선택한 이슈 유형에 맞는 issue template을 작성해준다.
        - bug issue (버그 리포트 이슈) 양식
            
            ```jsx
            ## 어떤 버그인가요?
            
            > 어떤 버그인지 간결하게 설명해주세요
            
            ## 어떤 상황에서 발생한 버그인가요?
            
            > (가능하면) Given-When-Then 형식으로 서술해주세요
            
            ## 예상 결과
            
            > 예상했던 정상적인 결과가 어떤 것이었는지 설명해주세요
            
            ## 참고할만한 자료(선택)
            ```
            
        - feature issue (기능 요청 이슈) 양식
            
            ```jsx
            ## 어떤 기능인가요?
            
            > 추가하려는 기능에 대해 간결하게 설명해주세요
            
            ## 작업 상세 내용
            
            - [ ] TODO
            - [ ] TODO
            - [ ] TODO
            
            ## 참고할만한 자료(선택)
            ```
            
        
        ![스크린샷 2025-02-27 오후 5.02.38.png](attachment:d7e67197-ab23-48d0-9e0c-c37e81eff5d8:스크린샷_2025-02-27_오후_5.02.38.png)
        
        ![스크린샷 2025-02-27 오후 5.03.17.png](attachment:5eeda6e2-010c-4c21-b65e-3e6bcfc8dd4d:스크린샷_2025-02-27_오후_5.03.17.png)
        
    7. 반드시 propose changes를 클릭해야 해당 변경 내용들이 커밋되어 저장될 수 있다.
        
        ![스크린샷 2025-02-27 오후 5.03.43.png](attachment:67681bdb-e17f-4a03-9385-7b3e10a4c7f8:스크린샷_2025-02-27_오후_5.03.43.png)
        
    8. 그럼 아래처럼 commit message와 함께 main으로 바로 commit 하는 버튼을 클릭한다.
        
        ![스크린샷 2025-02-27 오후 5.06.42.png](attachment:0da36278-3d51-4121-afcd-208e1d906d6e:스크린샷_2025-02-27_오후_5.06.42.png)
        
    9. issue_template commit 내역 올라가면서 적용됬을 것이다.
        
        ![스크린샷 2025-02-27 오후 5.08.02.png](attachment:9eefa54b-7761-4949-8869-0273710b2f0b:스크린샷_2025-02-27_오후_5.08.02.png)
        
- ISSUE 작성하는 법
    1. 이슈 만들 레포 들어가서 상단에 issue 탭 선택
        
        ![스크린샷 2025-02-27 오후 5.08.48.png](attachment:f80a48a0-32ab-4b4b-a176-05ad894510a1:스크린샷_2025-02-27_오후_5.08.48.png)
        
    2. new issue 버튼 누르면 우리가 만든 양식 유형의 이슈 와 기본 빈 이슈 중 선택하라고 뜬다.
        
        ![스크린샷 2025-02-27 오후 5.09.10.png](attachment:875d9ba2-7493-400b-87e0-e35601ef8060:스크린샷_2025-02-27_오후_5.09.10.png)
        
    3. 우리가 만든 양식 유형을 선택하면 템플릿 적용된 상태로 issue 생성할 수 있다.
        
        ![스크린샷 2025-02-27 오후 5.09.26.png](attachment:b6ddcfd6-e25f-42d7-b6ff-9558b1b3802d:스크린샷_2025-02-27_오후_5.09.26.png)
        
        <aside>
        ❓
        
        이슈 만들 때 꼭 보이는 것들, Assinees, Labels, Projects, Milestone
        
        - Assignees : 담당자 (즉,**해당 PR의 전반적인 작업 책임자)**
        - Labels : 해당 작업 유형
        - Projects : 연결할 프로젝트(프로젝트 없으면 안해도 됨)
        - Milestone : 프로젝트가 도달해야 하는 목표지점(없으면 안해도 됨)
            - Milestone을 사용하면, 한 가지의 목표에 여러 이슈가 등록되어 있을 때 해당 목표의 진행도가 얼마나 되는지 게이지 바 형태로 볼 수 있음
        </aside>
        

- PR Template 만드는 법
    
    vscode 에서 `.github` 폴더 만들고 안에 `pull_request_template.md` 파일 만들고 원하는 형식 사용
    
    ![스크린샷 2025-02-27 오후 4.45.59.png](attachment:644cdb45-7140-4871-8079-b927c3a76056:스크린샷_2025-02-27_오후_4.45.59.png)
    
    - pull request template 양식 (더 다양한 양식 많으니 구글에 찾아서 맘에 드는 것 쓰세요)
        
        ```markdown
        ## #️⃣연관된 이슈
        
        > ex. #이슈번호, #이슈번호
        
        ## 📝작업 내용
        
        > 이번 PR에서 작업한 내용을 간략히 설명해주세요(이미지 첨부 가능)
        
        ### 스크린샷 (선택)
        
        ## 💬리뷰 요구사항(선택)
        
        > 리뷰어가 특별히 봐주었으면 하는 부분이 있다면 작성해주세요
        >
        > ex. 메서드 XXX의 이름을 더 잘 짓고 싶은데 혹시 좋은 명칭이 있을까요?
        
        ```
        
    
- PR 날리는 법
    
    ![new pull request 클릭하세요.](attachment:dc65bb98-4871-467e-9965-2f9c41915a8d:스크린샷_2025-02-27_오후_5.12.05.png)
    
    new pull request 클릭하세요.
    
    👇🏻 이 아래가 핵심입니다. 브랜치를 잘 보셔야 해요.
    
    `main (PR 적용하여 merge될 브랜치) ← dev (변경사항 있는 브랜치)`  로 되어있죠? 
    
    내가 여태 개발한 dev 브랜치의 변경 내역을 main 으로 merge 하기 전에 PR 날린다는 뜻입니다.
    
    `어떤 브랜치 ← 어디서` , 즉, 어디서 어떤 브랜치로 PR을 날릴 건지 브랜치만 잘 확인해주세요!
    
    ![브랜치 잘 확인했으면 create pull request 로 만들어주기](attachment:71d09901-8369-4459-84d2-de335262e5b6:스크린샷_2025-02-27_오후_5.12.32.png)
    
    브랜치 잘 확인했으면 create pull request 로 만들어주기
    
    ![우리가 적용한 템플릿 잘 보이고, 내용 적고, title은 `feat: 친구 초대 기능 추가` 처럼 구체적으로 적기](attachment:ebdbcf87-726c-49e8-b1f8-7c50870328b4:스크린샷_2025-02-27_오후_5.13.05.png)
    
    우리가 적용한 템플릿 잘 보이고, 내용 적고, title은 `feat: 친구 초대 기능 추가` 처럼 구체적으로 적기
    
    ![PR 잘 생긴 것 확인](attachment:12e830f2-0825-4126-9478-8983e9b5e174:스크린샷_2025-02-27_오후_5.13.35.png)
    
    PR 잘 생긴 것 확인
    

<aside>
✔️

추가로 milestone,projects 만드는 것들 더 궁금하신 분들 위한 [아티클](https://velog.io/@pikadev1771/Github-%EC%9D%B4%EC%8A%88-%EB%A7%88%EC%9D%BC%EC%8A%A4%ED%86%A4) (하나하나 캡쳐한 게 맘에 듦)

</aside>

<aside>
💡

실습 전 준비사항 - 우리 실습 폴더 안에 `collabo` 라는 폴더 하나 만들어주세요.

(폴더명 겹쳐서 헷갈리지 않도록 하기 위함입니다.)

</aside>

### 실습) `git-practice-collabo` 에서 진짜 협업해보기 `스스로 해보기` ⭐⭐⭐

1. `git-practice-collabo` 레포를 `fork` 합니다.
    
    https://github.com/groom-practice/fe7-git-practice-collabo
    
2. 터미널 키시고 **collabo** 폴더로 들어가서 **fork 한 본인 레포 URL**을 복사해 `clone`해줍니다.
    - 하는 법 모르시는 분만 열어보세요.
        
        <터미널 명령어 추가 설명>
        
        - `ls` → 이 친구 입력하면 현재 본인이 위치한 폴더 안에 뭐가 있는지 볼 수 있음
        - `cd ..` → 현재 본인이 위치한 폴더에서 한 단계 밖으로 나가기
        
        <터미널에 순서대로 입력하세요>
        
        1. `cd Desktop/` → Desktop 폴더로 들어간다는 의미 (`바탕화면` 으로 한글 폴더일 수도 있음)
        2. `cd frontend/` → 우리 frontend 폴더를 바탕화면에 만들었으니 frontend 폴더로 들어가기
        3. `cd collabo/` → collabo 폴더 방금 만들었죠? 그 안으로 들어가줍니다.
        4. 이제 거기서 `git clone 아까복제한본인레포URL` 입력해주면 끝.
3. vscode 에서 방금 clone 한 `본인`레포 오픈
    
    즉, `collabo`폴더 안에 있는 `git-practice-collabo`를 열기
    
4. vscode에서 터미널 열고 `git remote -v`했을 때 origin 본인 이름 들어간 레포 주소 나와야 함
    
    <aside>
    ⭐
    
    https://github.com/`lisarnjs`/git-practice-collabo.git 처럼 
    
    lisarnjs 부분에 본인 깃헙 아이디 들어가 있어야 합니다.
    
    groom-practice면 본인 레포가 아닌 우리 실습용 레포를 열어주신 겁니다.
    
    </aside>
    
5. 여기까지 이상 없다면 `dev` 라는 새로운 브랜치 만들고, 
`본인이름영어로.md` 파일 만들고 `안녕하세요` 적은 후  add → commit → dev branch push해주세요.
    - 위 요구사항만 보고 스스로 고민해서 해보세요. 진짜 모르겠으면 열어보세요.
        
        <터미널에 순서대로 입력하세요>
        
        1. `git branch` → 현재 main branch인 것 확인하기
        2. `git switch -c dev`
        3. `본인이름영어로.md` 파일 만들고 `안녕하세요` 입력 후 
        4. `git add .`
        5. `git commit -m “안녕하세요 commit”`
        6. `git push origin dev`
        7. 내 레포에 dev 브랜치가 잘 올라갔는지 확인하세요.
6. 내 레포 `dev` 변경사항을 `groom-practice/fe7-git-practice-collabo` 레포의 `main` 으로 PR을 보내주세요.
    - 위 요구사항만 보고 스스로 고민해서 해보세요. 진짜 모르겠으면 열어보세요.
        1. new pull request 버튼 클릭
        
        ![스크린샷 2025-02-27 오후 11.24.45.png](attachment:dc095ada-742b-4836-aaca-d27f3395f6cd:스크린샷_2025-02-27_오후_11.24.45.png)
        
        1. 레포명, 브랜치명 잘 보고 Create pull request 버튼 클릭
        
        ![스크린샷 2025-02-27 오후 11.20.29.png](attachment:8432e0cd-2c66-444a-94c3-9f232ff4ddd8:스크린샷_2025-02-27_오후_11.20.29.png)
        
7. 다음으로 **본인 레포의 `main`**에서 `ISSUE & PR 템플릿`을 만들어보세요.
    
    이때 PR 생성할 때 이슈 템플릿을 먼저 만들었다면 
    
    `git pull origin main` 으로 최신화해줘야함!
    
8. `본인 레포 dev 브랜치`에 올라갔던 변경사항을 `본인 레포 main 브랜치`로 PR 날려보시고 
템플릿이 잘 적용되는 지 확인하세요.
    
    → 해당 PR의 merge 는 아직 하지 말아주세요.
    
9. vscode 에서 `git remote -v` 했을 때 본인 레포가 origin 으로 잘 뜨는지 재확인합니다.
10. `groom-practice/git-practice-collabo` 레포를 `upstream` 이라는 이름으로 remote 추가해줍니다.
    - 위 요구사항만 보고 스스로 고민해서 해보세요. 진짜 모르겠으면 열어보세요.
        
        <터미널에 순서대로 작성해주세요>
        
        1. git remote add upstream https://github.com/groom-practice/fe7-git-practice-collabo.git
        2. git remote -v 해주시면 origin ,upstream 두 개가 모두 보여야 합니다.
11. vscode 본인 레포 main 인 상태에서 upstream 의 main 코드를 땡겨와보세요.
    
    → 제가 main 에 더 변경사항 넣지 않았다면 아무일도 일어나지 않는 게 정상입니다.
    
    - 위 요구사항만 보고 스스로 고민해서 해보세요. 진짜 모르겠으면 열어보세요.
        
        <터미널에 입력해주세요>
        
        1. `git branch` → 본인 현재 브랜치가 main 인지 확인
        2. `git pull upstream main`
12. `groom-practice/git-practice-collabo` 로 돌아와서 PR들 구경해보시고 
comment 달아서 코드 리뷰처럼 코멘트 달아주세요.
13. 고생하셨습니다🎉

<aside>
💡

`groom-practice/git-practice-collabo` 레포에 있는 `본인이름한글로` 브랜치를 

동료 개발자가 코드를 올리는 곳이라고 생각하고, 깃헙에서 직접 파일 추가하여 커밋 만들어주고

`upstream 본인이름한글로` 의 내용을 pull 땡겨오시고, PR 도 보내보시는 등 

`본인이름한글로` 브랜치를 `main` 처럼 활용해서 연습해주세요.

</aside>

<aside>
💌

### 오늘의 미션

데일리 복습 미션을 진행해주세요!

✅ **이론 수업에서 실습이 진행된 경우**

1. 그날 배운 이론 수업 내용을 복습하면서 
잘 이해되지 않거나, 더 자세히 알아보고 싶은 키워드를 한 가지 선택한 후 
**구글**에 검색하여 아티클을 읽습니다.
2. 아래와 같이 내용을 작성한 후 제출합니다.
    1. 내가 추가적으로 공부한 내용 + 오늘 이론 수업 복습
    2. 오늘 실습 진행하며 가장 어려웠던 점
    3. 오늘 실습을 통해 배운 학습적인 내용
    4. 오늘 가장 기억에 남는 코드 (한 줄도 괜찮아요)
    5. 실습 결과물 스크린샷 첨부
    6. 내가 읽은 아티클 링크 첨부

**오늘 오후 5시 30분까지 오늘 생성된 [오늘의 미션] 스레드**에 

미션을 진행한 결과물(블로그, 노션, 깃헙 등등…)을 올려주세요🔥

</aside>
